---
title: Crystal 1.5.0 is released!
version: 1.5.0
summary:
thumbnail: +
author:
---

We are delivering a new release with several bugfixes and improvements. Below we list the most important or interesting changes, without mentioning several bugfixes and smaller enhancements. For more details, visit the [changelog](https://github.com/crystal-lang/crystal/releases/tag/1.5.0). Breaking changes are marked with ⚠️.

Pre-built packages are available on [GitHub Releases](https://github.com/crystal-lang/crystal/releases/tag/1.5.0) and our official distribution channels.
See [crystal-lang.org/install](https://crystal-lang.org/install/) for installation instructions.

## Stats

In this release we included [XXX changes since the 1.4.1 release](https://github.com/crystal-lang/crystal/pulls?q=is%3Apr+milestone%3A1.5.0) by XX contributors. We thank all the effort put into improving the language! ❤️

## Remarkable changes

### Method restrictions from instance variables

When an instance variable is assigned the value of an untyped method argument, then the argument is restricted to share the same type as the instance variable.

For instance, consider this code:

```crystal
class Foo
  @x : Int64

  def initialize(x)
    @x = x
  end
end
````

Up to 1.4.1, `x` in `initialize` is unrestricted. This had several issues:

 1. If the user passes an incorrect argument, like `Foo.new('a')`, then the error wrongly blames `@x` for not having the right type.

 2. No autocast is performed, for instance, if we pass an `Int32` instead: `Foo.new(1)` fails.

 3. The generated documentation doesn't provide a hint of the type of the parameter `x`.

From 1.5.0, in an assignment like `@x = x`, parameter `x` gets the type of `@x`, effectively solving the three issues above. Details can be read from [#12103](https://github.com/crystal-lang/crystal/pull/12103).

> Note: This new feature is expected to be backwards compatible. If for some reason it brings you a headache you can disable it passing `-Dno_restrictions_augmenter` in the build options. Let us know in the [issue tracker](https://github.com/crystal-lang/crystal/issues) about it.

### Annotations allowed on method arguments

It is now possible to add an annotation to a parameter of a method or macro, useful when needing to handle transformations in parameters. For instance, the following fictitious code allows to multiply the value received by the entrypoint `/multiply/{num}`, in this case doubling `num`:

```crystal
@[ARTA::Get(path: "/multiply/{num}")]
def multiply(@[Multiply(by: 2)] num : Int32) : Int32
  num
end
```

Details in [#12039](https://github.com/crystal-lang/crystal/issues/12039).

### ⚠️ Parameters of methods implementing an abstract `def` must match the names

In order to provide better documentation and robustness, it is possible to explicitly associate arguments with their names ([ref](https://crystal-lang.org/reference/1.4/syntax_and_semantics/default_and_named_arguments.html#named-arguments)):

```crystal
class Foo
  def foo(name : Int32) : Nil
    p name
  end
end

Foo.new.foo name: 42
```

As a consequence, it is sensible to consider that the name of an argument is part of its interface. Before 1.5.0, however, the compiler was not checking that the name of arguments matched between an implementation of an abstract method and its definition. That is, the following example compiled without error or warning:

```crystal
abstract class FooAbstract
  abstract def foo(number : Int32) : Nil
end

class Foo < FooAbstract
  def foo(name : Int32) : Nil
    p name
  end
end
```

Starting from 1.5.0 ([#11915](https://github.com/crystal-lang/crystal/pull/11915)) the example above will raise a warning:

```
 6 | def foo(name : Int32) : Nil
             ^---
Warning: positional parameter 'name' corresponds to parameter 'number' of the overridden method FooAbstract#foo(number : Int32), which has a different name and may affect named argument passing
```

We note, however, that there might be [false positives](https://github.com/crystal-lang/crystal/issues/12150).

### Constant indexers for tuples

When using a constant to index a tuple or named tuple, the typechecker will correctly infer the precise type of the value accessed ([#12012](https://github.com/crystal-lang/crystal/pull/12012)).

```crystal
KEY = "s"
foo = {s: "String", n: 0}

# Before 1.5.0 this failed; it would assume the type of foo[key] to be (String | Int32)
puts foo[KEY].size
```

### Windows native compiler gets an Eventloop

By merging [#12149](https://github.com/crystal-lang/crystal/pull/12149) we crossed an important check in the [road to native Windows support](https://github.com/crystal-lang/crystal/issues/5430).

---

We have been able to do all of this thanks to the continued support of [84codes](https://www.84codes.com/), [Nikola Motor Company](https://nikolamotor.com/) and every other [sponsor](/sponsors). To maintain and increase the development pace, donations and sponsorships are essential. [OpenCollective](https://opencollective.com/crystal-lang) is available for that. Reach out to [crystal@manas.tech](mailto:crystal@manas.tech) if you’d like to become a direct sponsor or find other ways to support Crystal. We thank you in advance!
